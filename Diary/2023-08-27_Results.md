# The Result type

The result type represent the result of an operation that can either succeed or fail. It serves as an alternative to a traditional combination of a return value (success) and an exception (failure). Instead of throwing exceptions on errors, some prefer to return special values to indicate errors, like null, or false, or some other arbitrary type.
The result type allows a standard way of returning errors without having to resort to special values.
The result type is basically a discriminated union of two types: a success type and a failure type. In the case of a success, the result can also contain a Value; the Value that the operation produced.
Analogous with a void method is the Result<Unit> type. It is used to represent operations that do not produce a value, but can still fail.

## When should I throw exceptions and when should I use an Error Result?
Exceptions still have their places. Consider the following example:
```csharp
public static Result<Unit>() AddTopping(Pizza pizza, Topping topping)
{
	if(pizza == null)
		throw new ArgumentNullException(nameof(pizza));
	if (topping == null)
		throw new ArgumentNullException(nameof(topping));
	if(pizza.Toppings.Contains(topping))
		return Result.Error<Unit>("Topping already added");
	pizza.Toppings.Add(topping);
	return Result<Unit>.Ok();
````

The compiler stops a caller from passing a null topping or a null pizza, but only if they have enabled "nullable reference types", so we can't be sure.
If the caller passes a null value as either argument, that's a programming error. The programmer certainly didn't intend to top null with cheese, and the program should crash. The programmer should fix the bug.
However, the compiler can't stop the caller from passing a topping that has already been added to the pizza. This rule has nothing to do with correctness of code, it's a business rule.
(is this really the argument I'm trying to make? I'm not so sure)

## If an operation cant fail, should I return a successful Result or just the value?

## Should I return void, Unit or Result<Unit> from an operation that doesn't return a value?





Implementation details
nullable value
different classes
Result 
ValueResult
Pure

tests on all claims of Result.
investigate ValueResult
analyzer to find thrown away results
analyzer that check that the success property was checked before accessing Value
